---
title: "Getting started with supreme"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Getting started with supreme}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
library(supreme)
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

## Create new models from scratch

### Read files containing your Shiny application

In **supreme** package, we provide path lead to an example application of Shiny
created with modules that resides in `inst/extdata` [*directory*](#todo-add-link) of the repository.

You can get the paths for the example app by calling `example_app_path()`:

```{r}
paths <- example_app_path()
paths
```

Then create a `supreme` object:

```{r}
s <- supreme(src_file(paths))
```

Visualize:

```{r}
graph(s)
```

Those all can be also done using pipes (`%>%`) from the [magrittr](https://cran.r-project.org/package=magrittr) package:

```{r, eval=FALSE}
src_file(paths) %>%
  supreme() %>% 
  graph()
```

### Read package containing Shiny application

The helper function `example_package()` contains an R package named `supreme.pkg.test` placed in [*this repository*](https://github.com/strboul/supreme.pkg.test).

```{r}
pkg.name <- example_package()
sup <- supreme(src_pkg(pkg.name))
graph(sup)
```


### Read expressions containing application

Create a new expression in R, and you will be able to analyze it by creating a supreme object:

```{r}
e <- expression({
  library(shiny)
  
  text_ui <- function(id) {
    ns <- NS(id)
    tagList(textInput(ns("text"), "Write here"),
            verbatimTextOutput(ns("display")))
  }
  
  text_server <- function(input, output, session) {
    rv.text <- reactiveValues(val = FALSE)
    
    observeEvent(input$text, {
      rv.text$val <- input$text
    })
    
    output$display <- renderText({
      rv.text$val
    })
    
  }
  
  ui <- fluidPage(fluidRow(
    column(6,
           text_ui("text"))
  ))
  
  server <- function(input, output, session) {
    callModule(module = text_server, id = "text")
  }
  
  shinyApp(ui, server)
})
s <- supreme(src_expr(e))
graph(s)
```

### Read application environment

```{r}
e <- example_environment()
s <- supreme(src_env(e))
graph(s)
```

## Analyse existing applications

### Creating YAML model objects

Model definition with YAML[^1] is quite useful to design new application or design part of the logic in the application.

Therefore, you can plan how modules should work each other, what module will call which, and what inputs they will have.

```{r}
model <- '
  - type: module
    name: server
    calling_modules: [items_tab_module_server, customers_tab_module_server, transactions_tab_module_server]
  
  - type: module
    name: items_tab_module_server
  
  - type: module
    name: customers_tab_module_server
    
  - type: module
    name: transactions_tab_module_server
'
```

There are some special rules when creating models with YAML. 

+ Each entity in the model must have 
*`r getOption("SUPREME_MODEL_REQUIRED_FIELDS")`* fields.

+ The entities can have optional fields which are
*`r getOption("SUPREME_MODEL_OPTIONAL_FIELDS")`*.

Any other field, which is not known by the supreme modal object, added to the model
definition would throw an error (e.g. adding a field called `apple: green` isn't
allowed).

See the [*Model language*](#model-language) section for explanation of these fields.

Create a supreme mode object:
```{r}
obj <- supreme(src_yaml(text = model))
obj
```

Visualize the supreme mode object:
```{r, fig.width = 7, fig.height=7}
graph(obj)
```


## Model language

A *supreme* object is consisted by *entities*. An '*entity*' denotes here a Shiny
server component that could either be a server side of a module or the main `server`
function of a Shiny application.

*supreme* objects can be created with YAML with the following structure[^2]:

1. Create an *entity* by using list members that are denoted by a leading hyphen
(`-`).

2. Each entity can have the following fields. The `type` and `name` fields are
absolute must to generate a `supreme` object. Other fields are optional, but they
enhance `supreme` objects.

2.1. `type` *(required)*: This should be straightforward "module" for now. The
possible entries, which this field can take, may be changed in the future.

2.2. `name` *(required)*: The name of the entity.

2.3. `input` *(optional)*: Input names which an entity can take. (If you have names
of a length greater than one, put them between square brackets (`[ ]`) whose entries
are delimited by commas.)

2.4. `output` *(optional)*: Output names which an entity can take. (This is under
development)

2.5. `calling_modules` *(optional)*: The names of the modules are called from that
entity via `callModule()` call.

2.6. `src` *(optional)*: A single location where the read resources (file paths,
package name etc.) can be found.

## Current limitations

+ Although it's possible to create a Shiny app by only providing `input` and `output`
arguments in the server side, *supreme* will not read any Shiny server side component
missing a `session` argument[^3].

+ *supreme* will not properly parse the source code of your application if server
side component is created with `shinyServer()`, which is kind of soft-deprecated
after a very early Shiny version `0.10`, because of the reason mentioned just above.

+ Some idiocratic Shiny application code may not be parsed as intended. It would be
great if you can open an issue with a reproducible example.

## Notes

[^1]: YAML is a popular is a human-readable data-serialization language. <https://yaml.org/>

[^2]: Please note that some of the directives here in terms of notations, symbols to use
are directly coming from the YAML specification.

[^3]: That's reasonable because modules cannot work without `session` argument and
supreme is a package designed to work with Shiny modules.

